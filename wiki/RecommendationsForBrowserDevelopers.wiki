Erik van der Poel, 22 Nov 2009, very rough draft

=== 1 Introduction ===

This document makes recommendations for browser developers who wish to transform URLs in the same way as other browsers. In addition to these interoperability considerations, some security recommendations are made.

This document is not intended to be a full specification. It only highlights the differences between the current versions of the browsers and makes a few interoperability and security recommendations.

=== 2 Document Conventions ===

Recommendations are in normal paragraphs like this one.

  _*Rationale*_ The rationale for the previous paragraph is given in paragraphs like this one.

  _*Diffs*_ Differences between the browsers are highlighted in paragraphs like this one.

Characters are written in the U+HHHH or U+HHHHHH notation, where H is a hex digit.

=== 3 Definitions ===

  * Character encoding: e.g. UTF-8, not to be confused with percent-encoding
  * IRI: Internationalized Resource Identifier, [http://www.rfc-editor.org/rfc/rfc3987.txt RFC 3987]
  * Percent-encoding: %HH where H is a hex digit, not to be confused with character encoding
  * URI: Uniform Resource Identifier, [http://www.rfc-editor.org/rfc/rfc3986.txt RFC 3986]
  * URL: Uniform Resource Locator, as defined in [http://dev.w3.org/html5/spec/Overview.html#terminology-0 HTML5]. URLs may contain mixtures of percent-encoded and not-percent-encoded non-ASCII text, so they are neither pure URIs nor pure IRIs

=== 4 Scope ===

This document is limited to discussion of HTML, Javascript, HTTP, HTTPS, FTP, IRI, URI, IDNA and DNS. All other markup languages, scripting languages, and network protocols are out of scope.

=== 5 Interoperability ===

In order to achieve interoperability, browsers must behave the same way in a number of areas, including protocol elements, script interfaces, user input, and display. User input and display are just as important because true interoperability includes human-to-human communication, not just machine-level interoperability.

APIs provided by the OS, such as DNS-related APIs called from a browser, are out of scope for this document.

==== 5.1 Protocol Elements ====

URLs appear in a number of protocol elements, including HTML attributes and HTTP requests. Also, the host name is often extracted from a URL in order to place it in other protocol elements like DNS packets and the HTTP Host request header.

When sending and receiving protocol elements, browsers must take care to achieve interoperability. The robustness principle is usually stated as follows.

  _Be conservative in what you do; be liberal in what you accept from others._

However, browsers have often been too liberal, and this has led to the proliferation of garbage on the Web. So the new recommendations are as follows.

  _Consumers should be as liberal as the major implementation(s), but not more liberal than that. Where security considerations are more important, consumers should be more conservative._

  _Producers should be conservative, to avoid constructs where consumers differ._

Note that a browser is both a consumer (of HTML documents, URLs typed by the user, etc) and a producer (of DNS packets, HTTP requests, etc).

==== 5.2 Script Interfaces ====

When browsers read and parse an HTML document, they build a DOM (Document Object Model) which can then be manipulated by scripts defined in or linked from the document. Browsers must therefore implement script interfaces to the same spec so that scripts can run the same way in any browser.

After building the initial DOM and displaying the document, browsers allow users to click on hyperlinks. At that point, browsers must resolve URLs and build network packets such as DNS queries and HTTP requests.

The following sections cover these areas in more detail.

=== 6 Parsing a URL ===

When an HTML implementation reads in an HTML file, it first converts the entire file from the original character encoding to one of the Unicode character encodings, often UTF-16. It then parses the HTML, converting character references like &#12345; to Unicode along the way. The details of these steps are not in scope for this document.

This section is about parsing URLs found in HTML attributes like the href in `<a href="...">`. After extracting the attribute value, the steps are as follows.

Note: Script interface tests will have to be written to confirm or expand upon the browser differences mentioned in this section. See section 8 "Resolving a URL" for test results that are more complete at this time. (TODO: In fact, some parts of this section must still be moved to section 8.)

*Step 1.* Remove white space from the beginning and end of the string.

*Step 2.* Remove TAB, LF and CR (U+0009, U+000A, U+000D) from the entire string.

  _*Diffs*_ IE also removes NUL (U+0000) from the entire HTML file. See [http://curlies.googlecode.com/svn/trunk/test_results/operating_systems/WinVista_SP1/path_ascii_results.html test results].

*Step 3.* Parse the URL, looking for the ASCII syntax characters such as : and /. Developers who wish to be compatible with IE should convert \ to / in all parts before the ?query and #fragment. The structure of a URL is `scheme://user:password@host:port/path;params?query#fragment`.

  _*Diffs*_ Some browsers terminate the host name at a semicolon, while others do not. See [http://curlies.googlecode.com/svn/trunk/test_results/operating_systems/WinVista_SP1/host_ascii_dns_results.html test results].

*Step 4.* User/password: If there is no user:password but there is an @, remove the @.

  _*Diffs*_ IE rejects http/https URLs with user:password, while Firefox accepts them.

*Step 5.* Host: Percent-decode the host name. If the result is not well-formed UTF-8, reject the URL. If the resulting host name contains any ASCII control characters (U+0000-1F, U+007F) or any URL syntax character (:@/\;?#%), reject the URL.

  _*Rationale*_ Control characters and syntax characters are considered "tricky" and rejected on security grounds.

  _*Diffs*_ Safari performs these steps in the wrong order, leading to a Punycode encoding of a string that contains a dot (U+002E). See the [http://curlies.googlecode.com/svn/trunk/test_results/operating_systems/MacOSX10_5_8/host_big5_dns_results.html test results].

Convert the non-ASCII dots specified by IDNA2003 to the ASCII dot (U+002E), and divide the host name into labels. If any label begins with "xn--", run it through the Punycode decoder. If the decoding fails or the resulting Unicode string contains character sequences that are not allowed in the versions of IDNA and Unicode implemented by the browser, leave the label in its original xn-- form.

If there are any non-ASCII bytes, perform Nameprep and Punycode. If either of these steps fail, reject the URL. IDNA2003 did not explicitly specify what to do with dots (U+002E) that appear as a result of the Nameprep step. The recommendation is to split the name into labels again after the Nameprep step. Finally, convert these Punycode labels back to Unicode.

*Step 6.* For the rest of the URL, percent-decode the unreserved ASCII characters (a-zA-Z0-9, etc). TODO: details.

*Step 8.* Params: These are defined for the ftp scheme. Web sites may use the semicolon (;) in URLs with the http/https schemes, but the client treats the params as just another string at the end of the path.

*Step 9.* Query: If the original character encoding of the HTML document was UTF-16- or UTF-32-based, convert the query to UTF-8. Otherwise, convert the query to the original character encoding.

  _*Rationale*_ Percent-decoding the fragment and running a character encoding detector on it lead to non-deterministic behavior. Scripts in the document environment can decide what to do with percent-encoded fragments, since they are more likely to have knowledge of the underlying character encoding.

  _*Diffs*_ Firefox percent-decodes the fragment and runs a character encoding detector.

=== 7 Script Interfaces ===

Scripts may run during the initial loading of a document and also afterwards, e.g. via timers and user input events. Browsers should implement the following interfaces in the same way in order to achieve interoperability.

Note: Javascript characters and strings are in UTF-16.

For the HTML tag `<a href="...">`, the following interfaces are available.

`this.href` returns the host name in Unicode, even if the original was in Punycode or percent-encoded UTF-8. Originally percent-encoded text in other parts of the URL are returned as is, while originally not-percent-encoded text is returned in Unicode. Note: This corresponds to IRI. TODO: Decide whether this interface should return the absolute URL or the relative URL.

  _*Diffs*_ IE and Firefox do not support percent-encoded UTF-8 in the host name.

`this.getAttribute('href')` returns the host name in Punycode, even if the original was in some other encoding. Other parts of the URL are returned in the format described in section 8 "Resolving a URL". Note: This corresponds to URI. TODO: Decide whether this interface should return the absolute URL or the relative URL.

  _*Diffs*_ Microsoft's interface allows an extra argument that controls relative vs absolute and Unicode vs Punycode host. See [http://msdn.microsoft.com/en-us/library/ms536429(VS.85).aspx their interface].

In summary, this area is a complete mess. Browser developers will have to discuss these, reach an agreement, and clean this up.

=== 8 Resolving a URL ===

TODO: Finish moving stuff from section 6 to this section.

Path and params: Convert to UTF-8 and percent-encode the non-ASCII bytes.

=== 9 User Input of a URL ===

=== 10 Displaying a URL ===

=== 11 References ===

TODO: add links below.

HTML5

IDNA2003

IDNAbis

IRI

IRIbis

URI